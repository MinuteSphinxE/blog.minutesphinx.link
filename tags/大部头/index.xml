<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>大部头 on MS工坊</title>
        <link>https://blog.minutesphinx.link/tags/%E5%A4%A7%E9%83%A8%E5%A4%B4/</link>
        <description>Recent content in 大部头 on MS工坊</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>by MinuteSphinx CC0</copyright>
        <lastBuildDate>Wed, 06 Aug 2025 12:43:13 +0200</lastBuildDate><atom:link href="https://blog.minutesphinx.link/tags/%E5%A4%A7%E9%83%A8%E5%A4%B4/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>从LaTeX到声明式</title>
        <link>https://blog.minutesphinx.link/p/%E4%BB%8Elatex%E5%88%B0%E5%A3%B0%E6%98%8E%E5%BC%8F/</link>
        <pubDate>Wed, 06 Aug 2025 12:43:13 +0200</pubDate>
        
        <guid>https://blog.minutesphinx.link/p/%E4%BB%8Elatex%E5%88%B0%E5%A3%B0%E6%98%8E%E5%BC%8F/</guid>
        <description>&lt;h2 id=&#34;所见即所得&#34;&gt;所见即所得
&lt;/h2&gt;&lt;p&gt;我们已经习惯了使用MS Word类似的操作逻辑来编写具有复杂排版的文档。假设我们要编写一张贺卡，祝你的朋友生日快乐，从一篇空文档开始，我们干的事情大概如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写下生日快乐四个字&lt;/li&gt;
&lt;li&gt;想一想，发现宋体小字号不太好看，于是选中切换成华文彩圆把字号拉到72px。&lt;/li&gt;
&lt;li&gt;发现要画一些背景上去，从网上下载一张图片换成背景&lt;/li&gt;
&lt;li&gt;意识到自己要写下来一些文字，于是敲进去一些祝福语。&lt;/li&gt;
&lt;li&gt;&amp;hellip;&amp;hellip;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种操作逻辑我们已经习以为常，从我们日常使用的MS Word，到Adobe InDesign之类的专业排版工具我们一直都在使用。这种操作逻辑有一个显而易见的优势：易于理解，我们把做的事情一步步写下来，然后按照顺序向软件发送命令，顺序很重要不能颠倒&amp;hellip;.等等。实际上这种操作逻辑有一个名字：命令式。我们把做一件事情的方法按照步骤写下来，按照顺序执行。这种编码方式深入人心，我们用它制作了相当多的卓越并且令人惊叹的排版作品：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.minutesphinx.link/p/%E4%BB%8Elatex%E5%88%B0%E5%A3%B0%E6%98%8E%E5%BC%8F/agency.png&#34;
	width=&#34;794&#34;
	height=&#34;613&#34;
	srcset=&#34;https://blog.minutesphinx.link/p/%E4%BB%8Elatex%E5%88%B0%E5%A3%B0%E6%98%8E%E5%BC%8F/agency_hu14332488341177252511.png 480w, https://blog.minutesphinx.link/p/%E4%BB%8Elatex%E5%88%B0%E5%A3%B0%E6%98%8E%E5%BC%8F/agency_hu10236148143314019672.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;这真的很好看&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;129&#34;
		data-flex-basis=&#34;310px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;但是这种方法其实存在一些问题：而这个在InDesign中最为显著，而受限于它本身的设计模式，Adobe, Microsoft都无法解决这个问题，反而让这个问题变得愈发的严重了。&lt;/p&gt;
&lt;p&gt;假设我们要排版一张页面，要像上图一样有精美的排版，我们需要完成一系列复杂的操作。这些复杂的操作可以被分解为更小的原子操作。问题在于：这些操作过多过繁杂还具有具有相对的顺序让事情变得更加糟糕了。每一个亮眼的特性可以被分解为几个毫不相干的操作之间的巧妙叠加——但是它巧妙过头了。记住&lt;strong&gt;这些操作能带来这样的结果&lt;/strong&gt;本身就要消耗不少心力，再者你在做的事情是创意性工作，你还需要根据一个自己想出来的亮眼效果，反推如何从一大堆原子操作的工具箱里组合出来他们。你还需要思考这些原子操作在这个巨大InDesign工具箱的哪个下拉菜单里。这些能力被称为一个排版设计师的“经验”，这些经验从无数的实践中获得，当然要花费很多时间。更显然的结论是InDesign一个简单的年更新就有可能将经验化为乌有——那它还真的能被称作经验吗？&lt;/p&gt;
&lt;p&gt;排版为内容服务，尤其是上图这种TTRPG规则的排版。如果你已经花了太多时间在“如何创造一个酷排版”上，你大概就没有那么多心力专注于内容本身了。所以你需要一种解决方案，它能根据你写下的文字内容自动生成酷的排版，当然怎么生成当然需要管，但是不要和内容耦合的那么深，以至于改一点内容排版就要大改的程度。&lt;/p&gt;
&lt;h2 id=&#34;做什么而非怎么做&#34;&gt;做什么而非怎么做
&lt;/h2&gt;&lt;p&gt;MS Office曾经试图解决这个问题：于是我们引入了从小学生演讲者到现代打工人都熟知于心的&amp;quot;模板&amp;quot;。从基本实现原理来看，PowerPoint模板本质上是一个带了一些元数据的一张已经被设计好的一些幻灯片。这些元数据指定了每张幻灯片是干什么用的，每张幻灯片上有几个内容可以去的文本框，当你想要一张酷酷的幻灯片的时候，只需要导入模板，创建你想要的一页幻灯片，然后把内容复制粘贴进去就行了。&lt;/p&gt;
&lt;p&gt;这已经足够高效了，但是不妨我们再幻想一下接下来我们应该怎么进一步发扬这种思想。我们应该有一种方法，根据纯文字生成幻灯片。我们只需要在文字里插入“这是标题”，“这是数据”，这里切换下一页之类的标签，但是我们不会细致到这里多少个像素，这里用什么字体，然后我们通过一种神奇的机器把这串实际上没有耗费多少精力的纯文本直接转化为漂亮的幻灯片！完全不用思考内容该怎么排布，因为这个神奇的机器会自己替你干！&lt;/p&gt;
&lt;p&gt;于是我们触及了 &lt;strong&gt;声明式范式&lt;/strong&gt; 的核心精髓。而早在个人电脑普及之初，甚至在图形界面成为主流之前，一种强大的&lt;strong&gt;声明式排版系统&lt;/strong&gt;就已经存在并深刻影响了计算机科学——它就是 &lt;strong&gt;LaTeX&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当然我们在没有“怎么做”的情况下无法完成任务，但是如果我们把&lt;strong&gt;内容（声明）&lt;/strong&gt; 和 &lt;strong&gt;排版（基于规则的转换）&lt;/strong&gt; 完全切分开，这本身就能给设计排版的过程减少大量负担。&lt;strong&gt;这种彻底的分离——不可变的内容声明与基于规则的样式转换——其思想内核与函数式编程追求纯函数（输出只取决于输入，无副作用）、不可变数据和高阶抽象的理念高度重合。&lt;/strong&gt; 我们将在探讨LaTeX之后，特别谈谈这些关系。&lt;/p&gt;
&lt;h2 id=&#34;具体如何&#34;&gt;具体如何？
&lt;/h2&gt;</description>
        </item>
        <item>
        <title>函数范式编程</title>
        <link>https://blog.minutesphinx.link/p/%E5%87%BD%E6%95%B0%E8%8C%83%E5%BC%8F%E7%BC%96%E7%A8%8B/</link>
        <pubDate>Mon, 30 Jun 2025 07:49:15 +0800</pubDate>
        
        <guid>https://blog.minutesphinx.link/p/%E5%87%BD%E6%95%B0%E8%8C%83%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid>
        <description>&lt;img src="https://blog.minutesphinx.link/p/%E5%87%BD%E6%95%B0%E8%8C%83%E5%BC%8F%E7%BC%96%E7%A8%8B/cover.webp" alt="Featured image of post 函数范式编程" /&gt;&lt;blockquote&gt;
&lt;p&gt;我本身也是第一次学习函数式编程，很多在这个文章里描写的东西可能有误，不过都出于我个人对此的了解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;从计算机发展史看编程范式&#34;&gt;从计算机发展史看编程范式
&lt;/h2&gt;&lt;p&gt;计算机的发展越来越进步，我们能用计算机干的事情也越来越多，我们一开始直接编写机器码，我们设计了冯·诺依曼架构，并且基于这个规定了一套汇编语言，汇编语言是基于&lt;strong&gt;工程实践&lt;/strong&gt;的对于硬件的字面描述，当我们要求助计算机完成人类无法完成任务的时候，我们分析我们的任务，把它从人类的思路转换为处理器的思路，然后我们直接操作处理器，操作寄存器，操作内存，直接阅读和写入IO来完成任务。&lt;/p&gt;
&lt;p&gt;随着计算机从一群科学家的狂欢变成更实用，更加商业化的东西，我们发明了编译器，我们可以通过一些更说人话的方法编写程序。所以我们有了Fortran和COBOL(出于美国政府的厕所管理员和火星人的邪恶交易的原因，这个语言还在银行系统里使用，实在是太邪恶了)，此时的编程语言基本上就是对于硬件的抽象描述（不再是字面描述了）和一大堆语法糖的混合。我们也第一次获得了一种不再是处理器特定的，&lt;em&gt;把人类思路转换为编程思路的方法&lt;/em&gt;，这个描述可能有点晦涩，不过请尽量理解其意思。&lt;/p&gt;
&lt;p&gt;随着计算机应用逐渐广泛，我们第一次出现了&lt;strong&gt;修订&lt;/strong&gt;这种方法的需求，于是我们发明了编程范式这个词，我们把流行的几种思路简单归类，就出现了面向对象编程，面向过程编程，函数式编程和其他几种范式。这几种范式各有优劣，在从第一台计算机发明到21世纪20年代，这些范式兴衰交替。&lt;/p&gt;
&lt;p&gt;强行谈这些范式出现的时间完全没有特别的意义，不过从上世纪80年代起，面向对象编程因为其很容易理解且符合人脑思路的特性随着工业和商业软件的爆发迅速崛起到今天，它的本质是“东西”（也就是对象），即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个世界上所有东西都是东西（废话）东西可以被归类 （万物皆对象）&lt;/li&gt;
&lt;li&gt;东西有特征 （对象有属性）&lt;/li&gt;
&lt;li&gt;你可以对东西做些什么 （对象有方法）&lt;/li&gt;
&lt;li&gt;某些类的东西共享相同的特征 （继承）&lt;/li&gt;
&lt;li&gt;某些类的东西可以做的东西有相同之处 （多态）&lt;/li&gt;
&lt;li&gt;数据以东西的特征表示 （状态存储在对象中）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这套逻辑很符合人脑的直觉，所以它经久不衰，但是它有一些更奇怪的问题：&lt;/p&gt;
&lt;h2 id=&#34;纯粹的编程&#34;&gt;纯粹的编程
&lt;/h2&gt;&lt;p&gt;面向对象里我们发明了很多概念，我们通过这些概念把程序束缚在接口里，把状态安全的束缚在属性里，我们通过继承来重用代码，后来我们发现多重继承搞出的麻烦远比继承本身带来的好处多，于是我们发明了组合优于继承，我们用Tag和捆绑在Tag上的特性小心的修饰基类来避免更多麻烦…但是我们大部分时候好像并不需要那么多东西，我们不需要为了发明一个洗衣机先发明一个电器，而这个电器为了可扩展性需要兼容食品处理操作，虽然我们永远用不到洗衣机做饭。&lt;/p&gt;
&lt;p&gt;我们需要意识到我们大部分时候，或者广义上的所有时候只是把数据从一个地方拿出来煮熟剁碎烤干再放到另外一个地方去，我们并不需要设计一大堆复杂的鬼哭狼嚎的，于是函数式编程在这些日子重新兴起，因为它做了减法：&lt;/p&gt;
&lt;p&gt;第一个被砍掉的东西是状态本身，编程编程，数据是人类灌进去的，而我们只需要描述如何处理这些数据就行了。而状态本身是运行时该管理的事情。&lt;/p&gt;
&lt;p&gt;既然状态根本不存在，那同样的数据一定会带来同样的结果！那这就是数学中的函数，函数编程称其为纯函数。&lt;/p&gt;
&lt;p&gt;数学中的函数不应该干计算以外的所有东西，所以它不能修改外部变量，读写文件，处理网络，因为它只是数学意义上的函数！这些复杂的副作用是运行时该处理的事情。&lt;/p&gt;
&lt;p&gt;函数的结果自然可以塞进另外一个函数里，数据流水线可以简单的拼装起来。&lt;/p&gt;
&lt;p&gt;比起传递一大堆奇怪的属性集，那我们为什么不能直接传递函数？于是我们得到了高阶函数。高阶函数&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
